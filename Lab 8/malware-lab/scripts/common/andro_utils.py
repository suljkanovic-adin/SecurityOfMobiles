# ---------------------------------------------------------------------------
# scripts/common/andro_utils.py
# ---------------------------------------------------------------------------

"""Utility wrappers around Androguard for static malware analysis.

All functions raise exceptions on failure so that the calling CLI can decide
how to deal with them (retry, log‑only, abort…).  Logging is configured at the
module level but may be overridden by applications.
"""

from __future__ import annotations

import hashlib
import logging
import os
from pathlib import Path
from typing import Iterable, Iterator, List, Set, Tuple

from androguard.core.analysis.analysis import MethodAnalysis
from androguard.misc import AnalyzeAPK

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


# ----- core helpers ---------------------------------------------------------

def load_apk(apk_path: os.PathLike | str):
    """Return the (a, d, dx) triple produced by ``AnalyzeAPK``.

    Parameters
    ----------
    apk_path : os.PathLike | str
        Path to the APK file on disk.

    Raises
    ------
    FileNotFoundError
        If *apk_path* does not exist or is not a file.
    RuntimeError
        If Androguard raises any exception while analysing the APK.
    """
    apk_path = Path(apk_path)
    if not apk_path.is_file():
        raise FileNotFoundError(apk_path)

    logger.debug("Loading APK: %s", apk_path)
    try:
        return AnalyzeAPK(str(apk_path))  # (APK, Dalvik bytecode, Analysis)
    except Exception as exc:  
        logger.exception("Androguard failed on %s", apk_path)
        raise RuntimeError("Androguard analysis failure") from exc


def compute_sha256(apk_path: os.PathLike | str) -> str:
    """Return the SHA‑256 hash of *apk_path* (hex string)."""
    sha256 = hashlib.sha256()
    with open(apk_path, "rb") as fh:
        for chunk in iter(lambda: fh.read(65536), b""):
            sha256.update(chunk)
    return sha256.hexdigest()


# ----- enumeration wrappers -------------------------------------------------

def iter_permissions(a) -> Set[str]:
    """Yield the set of dangerous permissions requested by *a* (APK object)."""
    return set(a.get_permissions())


def iter_api_calls(dx) -> Iterator[str]:
    """Yield fully‑qualified method names defined **inside** the APK.

    External methods are ignored because they belong to the Android framework
    or third‑party libraries and are therefore not direct evidence of malicious
    code inside the package.
    """
    for method_analysis in dx.get_methods():
        method: MethodAnalysis = method_analysis
        if method.is_external():
            continue
        yield f"{method.get_method().get_class_name()}->" \
          f"{method.get_method().get_name()}"


def iter_strings(d) -> Iterator[str]:
    """Yield all string literals embedded in any Dex file of the APK."""
    yield from d.get_strings()